---
name: 'v1.1.0'
date: '2024-01-09'
---

Features:
- The `type::is::record()` function now accepts a second optional table argument, validating the record being - stored on the passed table.
- Add `time::micros()`, `time::millis()` and `time::from::nanos` functions.
- Add `type::is::none()` function.
- Add `object::entries()`, `object::from_entries()`, `object::len()`, `object::keys- ()` and `object::values()` functions.
- Clean paths in the start command and honour `~`.
- CLI: Split results by comment.
- Add `surreal sql` welcome message.
- Add Debugging env flag: `SURREAL_INSECURE_FORWARD_SCOPE_ERRORS`.
- Add `SURREAL_ROCKSDB_KEEP_LOG_FILE_NUM` environment variable (default 20).
- Support auth levels for basic auth (behind feature flag)
- Add remainder/modulo operator.
- Implement string prefixes: `s`, `r`, `d` and `u`.
- Add ability to cast string to a Thing/Record ID.
- Analyzers to support functions.
- Support of subfields for embedding indexing.
- Add live query API to Rust SDK.
- Add `Query::with_stats()` to return query statistics along with the results.
- Permissions are now always displayed for visiblity
- Add a `--beta` flag to `surreal upgrade` to make installing the latest beta release easier.

Bug fixes:
- Fix stack overflow in graph traversal.
- Bugfix - parse error for invalid leading whitespace.
- Fix memory leak caused by OTEL callbacks.
- Fix wrong function name export and function name parsing.
- The position of the `LIMIT` and `ORDER` clauses are now interchangable.
- Fix index plan for idiom param value.
- Fix bug where error offset could underflow.
- Query results should be consistent and representative.
- Indexes used with the operators `CONTAINS [ ANY | ALL ]`.
- Forward custom thrown errors in `SIGNIN` and `SIGNUP` queries.
- Fix `ORDER BY RAND()` failing to parse when selecting specific fields.
- Fix identifiers which look like numbers failing to parse.
- Change math::median indexing for even length arrays.
- Pass IP & Origin onto session used by scope queries.
- Fix possible corruption of MTree and incomplete knn.
- Allow `array::flatten()` to be used as an aggregate function.
- Make `SELECT ONLY` deterministic.
- Optional function arguments should be optional.
- Default table permissions should be `NONE`
- Bugfix: Fix inconsistant record parsing
- Fix time regression in `surrealdb.wasm` binaries.
- Fix computing futures in query conditions.
- Fix issue with scoring on complex queries.
- Fix ML support on Windows and enable the feature in Windows binaries.
- Replace the custom JWT parser causing decoding issues.
- Ensure compression is only enabled when response is a certain size.
- Respect alias for dynamic field queries with `type::field()`.
- Prevent overflow in `math::power()`.
- Fix error message pointing to wrong character.
- Expand logic for static value validation to improve `DEFAULT` clause handling.
- Fallback to a string when record ID parsing fails.
- Ensure an attempt to set a protected variable returns an error.
- Fix duration addition in timeout causing overflow.
- Fix a bug where a non-empty list parser would parse empty lists.
- Limit recursion depth when parsing nested `RELATE` statements.
- Ensure `REMOVE` statement does not only remove the first 1000 keys.
- Fix BTree deletion bug.
- Replace close method on `live::Stream` with a Drop trait implementation.

Performance improvements:
- Enable compression on the HTTP connector.
- Make `REMOVE [ TABLE | DATABASE | NAMESPACE ]` faster for TiKV and FoundationDB.
- Repetitive expressions and idioms are not anymore re-evaluated.
- Improve performance of `CREATE` statements, and record insertion.
- Improve RocksDB performance and configuration, introducing `SURREAL_ROCKSDB_THREAD_COUNT`, `SURREAL_ROCKSDB_WRITE_BUFFER_SIZE`, `SURREAL_ROCKSDB_TARGET_FILE_SIZE_BASE`, `SURREAL_ROCKSDB_MAX_WRITE_BUFFER_NUMBER`, `SURREAL_ROCKSDB_MIN_WRITE_BUFFER_NUMBER_TO_MERGE`, `SURREAL_ROCKSDB_ENABLE_PIPELINED_WRITES`, `SURREAL_ROCKSDB_ENABLE_BLOB_FILES`, `SURREAL_ROCKSDB_MIN_BLOB_SIZE` environment variables.
- Improve SpeeDB performance and configuration, introducing `SURREAL_SPEEDB_THREAD_COUNT`, `SURREAL_SPEEDB_WRITE_BUFFER_SIZE`, `SURREAL_SPEEDB_TARGET_FILE_SIZE_BASE`, `SURREAL_SPEEDB_MAX_WRITE_BUFFER_NUMBER`, `SURREAL_SPEEDB_MIN_WRITE_BUFFER_NUMBER_TO_MERGE`, `SURREAL_SPEEDB_ENABLE_PIPELINED_WRITES`, `SURREAL_SPEEDB_ENABLE_BLOB_FILES`, `SURREAL_SPEEDB_MIN_BLOB_SIZE` environment variables.
- Improve WebSocket performance, introduce `SURREAL_WEBSOCKET_MAX_FRAME_SIZE`, `SURREAL_WEBSOCKET_MAX_MESSAGE_SIZE`, `SURREAL_WEBSOCKET_MAX_CONCURRENT_REQUESTS` environment variables.
- Use specific memory allocators depending on OS.
- Fix memory leak in Websocket implementation.

#### Get realtime updates in your Rust application with the Live Query API

`v1.1.0` introduces a new Live Query API to the Rust SDK, for powerful realtime updates in your Rust applications.

```rust
// Select the namespace/database to use
db.use_ns("namespace").use_db("database").await?;

// Listen to all updates on a table
let mut stream = db.select("person").live().await?;

// Listen to updates on a range of records
let mut stream = db.select("person").range("jane".."john").live().await?;

// Listen to updates on a specific record
let mut stream = db.select(("person", "h5wxrf2ewk8xjxosxtyc")).live().await?;

// The returned stream implements `futures::Stream` so we can
// use it with `futures::StreamExt`, for example.
while let Some(result) = stream.next().await {
	handle(result);
}

// Handle the result of the live query notification
fn handle(result: Result<Notification<Person>>) {
	match result {
		Ok(notification) => println!("{notification:?}"),
		Err(error) => eprintln!("{error}"),
	}
}
```

#### Object functions

It was previously impossible to iterate over objects, so we introduced some new functions to make working with object data structures easier.

```surql
LET $fruits = {
	apple: {
		name: "Apple",
		stock: 20,
	},
	banana: {
		name: "Banana",
		stock: 40,
	},
};

LET $num_fruit_types = object::len($fruits);
LET $num_fruit_total = math::sum((
	SELECT VALUE stock FROM object::values($fruits)
));

RETURN "We have " + <string> $num_fruit_types + " type of fruits.";
RETURN "We have " + <string> $num_fruit_total + " pieces of fruit in total.";
```

#### String prefixes

Strings can optimistically be parsed as Record IDs, Datetimes or as a UUID, if the content matches such a value. With string prefixes you get to decide what value a string holds.

```surql
-- Interpeted as a record ID, because of the structure with the semicolon:
RETURN "5:20";
-- Forcefully parsed as just a string
RETURN s"5:20";

-- This will be a record ID.
RETURN r"person:john";
-- This fails, as it's not a valid record ID.
RETURN r"I am not a record ID";

-- Example for a date and a UUID.
RETURN d"2023-11-28T11:41:20.262Z";
RETURN u"8c54161f-d4fe-4a74-9409-ed1e137040c1";
```

#### Deterministic `SELECT ONLY`

The `ONLY` clause is sometimes not deterministic. Selecting from an array, table or range with the `ONLY` clause now requires you to limit the result to `1`.

```surql
-- Fails, not limited to 1 result and result can contain multiple outputs.
SELECT * FROM ONLY table_name;

-- Works! Resource gets returned, or NONE if no resource was found.
SELECT * FROM ONLY table_name LIMIT 1;
```

#### Optional function arguments

Optional function arguments on custom functions are now actually optional.

```surql
DEFINE FUNCTION fn::create::resource($required: string, $optional: option<string>) {
	// The $required argument is a string
	// The $optional argument is a string or NONE
};

// Previously you needed to pass NONE for optional arguments
fn::create::resource("Required argument", NONE);

// Now you simply omit the argument
fn::create::resource("Required argument");

```
